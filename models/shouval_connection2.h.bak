
/*
*  ttl_synapse.h
*
*  This file is part of NEST.
*
*  Copyright (C) 2004 The NEST Initiative
*
*  NEST is free software: you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 2 of the License, or
*  (at your option) any later version.
*
*  NEST is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
*
*  2020-10-29 13:15:31.388998
*/

#ifndef TTL_SYNAPSE_H
#define TTL_SYNAPSE_H

// C++ includes:
#include <cmath>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_odeiv.h>
//#include <cstdio>
#include <sstream>


// Includes from nestkernel:
#include "common_synapse_properties.h"
#include "connection.h"
#include "connector_model.h"
#include "event.h"
#include "logging.h"

// Includes from sli:
#include "dictdatum.h"
#include "dictutils.h"


/** @BeginDocumentation

Authors
+++++++

Zajzon


**/

#define DYAD_POST_TYPE

namespace nest {

struct SolverParams2_
{
  SolverParams2_() {};
  SolverParams2_(const SolverParams2_ &sp)
  {
    params[tau_w] = sp.params[tau_w];
    params[Tp_max_] = sp.params[Tp_max_];
    params[Td_max_] = sp.params[Td_max_];
    params[tau_ltp_] = sp.params[tau_ltp_];
    params[tau_ltd_] = sp.params[tau_ltd_];
    params[eta_ltp_] = sp.params[eta_ltp_];
    params[eta_ltd_] = sp.params[eta_ltd_];
    params[reward_on] = sp.params[reward_on];
    params[refractory_on] = sp.params[refractory_on];
  };

  enum SolverParamsVecElems
  {
    tau_w,
    Tp_max_,
    Td_max_,
    tau_ltp_,
    tau_ltd_,
    eta_ltp_,
    eta_ltd_,
    learn_rate,
    reward_on,
    refractory_on,

    State2_VEC_SIZE
  };
  double params[State2_VEC_SIZE];
};

struct State2_
{
  enum StateVecElems
  {
    // numeric solver state variables
    w,
    trace_ltp,
    trace_ltd,
    rate_pre,
    rate_post,

    State2_VEC_SIZE
  };

  //! state vector, must be C-array for GSL solver
  double y_[State2_VEC_SIZE];

  State2_() {};
  State2_( const State2_& ) {};
};

extern "C" inline int ShouvalConnection2Dynamics(double t, const double y[], double f[], void* psyn)
{
  typedef nest::State2_ S;
  const SolverParams2_& sP = *( reinterpret_cast< SolverParams2_* > ( psyn ) );

  const double& rate_pre = y[ S::rate_pre ];
  const double& rate_post = y[ S::rate_post ];

  double hebbian_ltp = sP.params[SolverParams2_::eta_ltp_] * rate_pre * rate_post;
  double hebbian_ltd = sP.params[SolverParams2_::eta_ltd_] * rate_pre * rate_post;
  double eff_saturation_ltp = sP.params[SolverParams2_::Tp_max_] * hebbian_ltp /
                              (sP.params[SolverParams2_::Tp_max_] + hebbian_ltp);
  double eff_tc_ltp = sP.params[SolverParams2_::Tp_max_] * sP.params[SolverParams2_::tau_ltp_] /
                      (sP.params[SolverParams2_::Tp_max_] + hebbian_ltp);

  double eff_saturation_ltd = sP.params[SolverParams2_::Td_max_] * hebbian_ltd /
                              (sP.params[SolverParams2_::Td_max_] + hebbian_ltd);
  double eff_tc_ltd = sP.params[SolverParams2_::Td_max_] * sP.params[SolverParams2_::tau_ltd_] /
                      (sP.params[SolverParams2_::Td_max_] + hebbian_ltd);

  f[ S::rate_pre ] = -rate_pre / sP.params[ SolverParams2_::tau_w ];
  f[ S::rate_post ] = -rate_post / sP.params[ SolverParams2_::tau_w ];

  if (sP.params[SolverParams2_::refractory_on] > 1e-5) {
    // refractory on!
    f[ S::trace_ltp ] = 0;
    f[ S::trace_ltd ] = 0;
  }
  else {
    f[ S::trace_ltp ] = -1 / eff_tc_ltp * (y[ S::trace_ltp ] - eff_saturation_ltp);
    f[ S::trace_ltd ] = -1 / eff_tc_ltd * (y[ S::trace_ltd ] - eff_saturation_ltd);
  }

  // reward on!
  if (sP.params[SolverParams2_::reward_on] > 1e-5) {
    f[ S::w ] = sP.params[SolverParams2_::learn_rate] * (y[ S::trace_ltp ] - y[ S::trace_ltd ]);
  }
  else {
    f[ S::w ] = 0;
  }

  return GSL_SUCCESS;
}

/** @BeginDocumentation

**/
class ShouvalConnection2CommonSynapseProperties : public CommonSynapseProperties {
public:

  ShouvalConnection2CommonSynapseProperties()
    : CommonSynapseProperties() {
  }

  /**
   * Get all properties and put them into a dictionary.
   */
  void get_status(DictionaryDatum &d) const {
    CommonSynapseProperties::get_status(d);
  }


  /**
   * Set properties from the values given in dictionary.
   */
  void set_status(const DictionaryDatum &d, ConnectorModel &cm) {
    CommonSynapseProperties::set_status(d, cm);
  }

  // N.B.: we define all parameters as public for easy reference conversion later on.
  // This may or may not benefit performance (TODO: compare with inline getters/setters)
};


/**
 * Class representing a static connection.
 */
template<typename targetidentifierT>
class ShouvalConnection2 : public Connection<targetidentifierT> {

public:
  typedef ShouvalConnection2CommonSynapseProperties CommonPropertiesType;
  typedef Connection<targetidentifierT> ConnectionBase;

  /**
  * Default constructor.
  *
  * Sets default values for all parameters (skipping common properties).
  *
  * Needed by GenericConnectorModel.
  */
  ShouvalConnection2();


  /**
  * Copy constructor from a property object.
  *
  * Sets default values for all parameters (skipping common properties).
  *
  * Needs to be defined properly in order for GenericConnector to work.
  */
  ShouvalConnection2(const ShouvalConnection2 &rhs);

  void init_buffers_();
  void init_internals_block_symbols();

  // Explicitly declare all methods inherited from the dependent base
  // ConnectionBase. This avoids explicit name prefixes in all places these
  // functions are used. Since ConnectionBase depends on the template parameter,
  // they are not automatically found in the base class.
  using ConnectionBase::get_delay_steps;
  using ConnectionBase::set_delay_steps;
  using ConnectionBase::get_delay;
  using ConnectionBase::set_delay;
  using ConnectionBase::get_rport;
  using ConnectionBase::get_target;

  /**
   * Get all properties of this connection and put them into a dictionary.
   */
  void get_status(DictionaryDatum &d) const;

  /**
   * Set properties of this connection from the values given in dictionary.
   */
  void set_status(const DictionaryDatum &d, ConnectorModel &cm);

  class ConnTestDummyNode : public ConnTestDummyNodeBase {
  public:
    // Ensure proper overriding of overloaded virtual functions.
    // Return values from functions are ignored.
    using ConnTestDummyNodeBase::handles_test_event;

    port
    handles_test_event(SpikeEvent &, rport) {
      return invalid_port_;
    }

  };

  void
  check_connection(Node &s, Node &t, rport receptor_type, const CommonPropertiesType &) {
    ConnTestDummyNode dummy_target;
    ConnectionBase::check_connection_(dummy_target, s, t, receptor_type);
    t.register_stdp_connection(t_lastspike_ - get_delay(), get_delay());
  }

  inline void set_weight(double w) {
    weight_ = w;
  }

  void
  print_state(std::ostringstream &msg) {
    msg << "\tState:"
        << "\n\t\tT_ltp / T_ltd: " << S_.y_[State2_::trace_ltp] << " / " << S_.y_[State2_::trace_ltd]
        << "\n\t\tw: " << S_.y_[State2_::w] << "\n";
  }

  void
  store_interval_sampling_state(const double cur_tp, const double ref_tp) {
    /**
     * Sample and log/store LTP and LTD traces, as well as the weight, at regular intervals to stdout.
     */
    if (P_.sampling_interval >= 1.0 and cur_tp == ref_tp) {
      V_.sampled_times.push_back(ref_tp);
      V_.sampled_ltp.push_back(S_.y_[State2_::trace_ltp]);
      V_.sampled_ltd.push_back(S_.y_[State2_::trace_ltd]);
      V_.sampled_weights.push_back(S_.y_[State2_::w]);
      V_.sampled_hebbian.push_back(S_.y_[State2_::rate_pre] * S_.y_[State2_::rate_post]);
    }
  }

  bool check_and_advance_reward_counter(const double t_spike, std::ostringstream &msg) {
    /**
     *
     */
    // advance reward counter if current spike is beyond the next reward onset
    if (V_.__t_reward_idx + 1 < P_.reward_times.size() and
        t_spike >= P_.reward_times[V_.__t_reward_idx + 1])
    {
      ++V_.__t_reward_idx;
      msg << "advance reward counter: " << P_.reward_times[V_.__t_reward_idx] << "\n";
      return true;
    }
    return false;
  }

  void
  evolve_dynamics(const double t_spike) {
    /**
     *
     */
    std::ostringstream msg;
    B_.__integration_step = nest::Time::get_resolution().get_ms();  // start with smallest step possible
    SolverParams2_ *tmpSP = reinterpret_cast<SolverParams2_*>(B_.__sys.params);
    // update some parameters so that ODE solver matches current values
    tmpSP->params[SolverParams2_::tau_w] = P_.tau_w;
    tmpSP->params[SolverParams2_::Tp_max_] = P_.Tp_max;
    tmpSP->params[SolverParams2_::Td_max_] = P_.Td_max;
    tmpSP->params[SolverParams2_::tau_ltp_] = P_.tau_ltp;
    tmpSP->params[SolverParams2_::tau_ltd_] = P_.tau_ltd;
    tmpSP->params[SolverParams2_::eta_ltp_] = P_.eta_ltp;
    tmpSP->params[SolverParams2_::eta_ltd_] = P_.eta_ltd;
    tmpSP->params[SolverParams2_::learn_rate] = P_.learn_rate;

    const double t_curspike_ = t_spike;
    double t1;
    double tp = t_lastspike_;

    msg << "Processing steps (evolve dynamics)...\n";

    while (abs(tp - t_curspike_) > 0.01) {
      double t_reward_on = P_.reward_times[V_.__t_reward_idx];
      double t_reward_off = P_.reward_times[V_.__t_reward_idx] + P_.T_reward;
      double t_ref_on = t_reward_off + nest::Time::get_resolution().get_ms();
      double t_ref_off = t_ref_on + P_.T_tr;

      assert(t_reward_on);
      assert(t_reward_off);
      msg << "State:"
          << "\n\tCURRENT TP: " << tp
          << "\n\tt_reward_on / off: " << t_reward_on << " / " << t_reward_off
          << "\n\tt_refractory_on / off: " << t_ref_on << " / " << t_ref_off << "\n";

      ///////////////////////
      // before reward onset
      if (tp < t_reward_on) {
        t1 = std::min(t_curspike_, t_reward_on) - tp;

        msg << "==> \tt_lastspike_ < t_reward_on: [" << tp
            << ", " << std::min(t_curspike_, t_reward_on) << "] => " << t1 << " steps\n";

        double t = 0.0;
        while ( t < t1 )
        {
          const int status = gsl_odeiv_evolve_apply(B_.__e, B_.__c, B_.__s, &B_.__sys, &t, t1,
                                                    &B_.__integration_step, S_.y_);
          if (status != GSL_SUCCESS) {
            throw nest::GSLSolverFailure("ShouvalConnection2", status);
          }
        }
        print_state(msg);
        tp = std::min(t_curspike_, t_reward_on);
      }

      //////////////////////////////////////////////////////
      // during reward window
      if (t_curspike_ >= t_reward_on && tp < t_reward_off) {
        // if tp == t_reward_on, we are at the moment of reward; dump the time and trace values
        store_interval_sampling_state(tp, t_reward_on);

        tmpSP->params[SolverParams2_::reward_on] = 1;
        t1 = std::min(t_curspike_, t_reward_off) - tp;

        msg << "==> \tt_curspike_ >= t_reward_on (REWARD Window): ["
            << tp << ", " << std::min(t_curspike_, t_reward_off) << "] => " << t1 << " steps\n";

        double t = 0.0;
        while ( t < t1 )
        {
          const int status = gsl_odeiv_evolve_apply(B_.__e, B_.__c, B_.__s, &B_.__sys, &t, t1,
                                                    &B_.__integration_step, S_.y_);
          if (status != GSL_SUCCESS) {
            throw nest::GSLSolverFailure("ShouvalConnection2", status);
          }
        }
        tmpSP->params[SolverParams2_::reward_on] = 0;
        print_state(msg);
        tp = std::min(t_curspike_, t_reward_off);
        store_interval_sampling_state(tp, t_reward_off);
      }

      ////////////////////////////////////////////////
      // during eligibility refractory window
      if (t_curspike_ >= t_ref_on && tp < t_ref_off) {
        tmpSP->params[SolverParams2_::refractory_on] = 1;
        t1 = std::min(t_curspike_, t_ref_off) - std::max(tp, t_ref_on);

        msg << "==> \tt_curspike_ >= t_ref_on (Refractory Window): ["
            << std::max(tp, t_ref_on) << ", " << std::min(t_curspike_, t_ref_off)
            << "] => " << t1 << " steps\n";

        double t = 0.0;
        while ( t < t1 )
        {
          const int status = gsl_odeiv_evolve_apply(B_.__e, B_.__c, B_.__s, &B_.__sys, &t, t1,
                                                    &B_.__integration_step, S_.y_);
          if (status != GSL_SUCCESS) {                            throw nest::GSLSolverFailure("ShouvalConnection2", status);
          }
        }
        tmpSP->params[SolverParams2_::refractory_on] = 0;

        // need to reset traces during refractory window !!!
        S_.y_[State2_::trace_ltp] = 0;
        S_.y_[State2_::trace_ltd] = 0;
        print_state(msg);
        tp = std::min(t_curspike_, t_ref_off);
        store_interval_sampling_state(tp, t_ref_off);
      }

      ////////////////////////////////////////////////////////////
      // after eligibility refractory window offset
      if (t_curspike_ > t_ref_off and P_.sampling_interval < 1.) {
        double next_reward_on = 1e12;
        // check if current spike is actually beyond the next reward zone
        if (check_and_advance_reward_counter(t_curspike_, msg)) {
          next_reward_on = P_.reward_times[V_.__t_reward_idx];
        }
        t1 = std::min(t_curspike_, next_reward_on) - std::max(tp, t_ref_off);

        msg << "==> \tt_curspike_ > t_ref_off (Refractory Window): ["
            << std::max(tp, t_ref_off) << ", " << std::max(tp, t_ref_off) + t1
            << "] => " << t1 << " steps\n";

        double t = 0.0;
        while ( t < t1 )
        {
          const int status = gsl_odeiv_evolve_apply(B_.__e, B_.__c, B_.__s, &B_.__sys, &t, t1,
                                                    &B_.__integration_step, S_.y_);
          if (status != GSL_SUCCESS) {
            throw nest::GSLSolverFailure("ShouvalConnection2", status);
          }
        }
        print_state(msg);
        tp = std::min(t_curspike_, next_reward_on);
      }
        ////////////////////////////////////
        /// try to sample inbetween
      else if (t_curspike_ > t_ref_off) {
        msg << "==> \tt_curspike_ > t_ref_off (Outside Refractory Window): interval sampling!!!"
               " [tp = " << tp << ", t_curspike_ = " << t_curspike_ << "\n";

        double next_reward_on = 1e12;
        // check if current spike is actually beyond the next reward zone
        if (check_and_advance_reward_counter(t_curspike_, msg)) {
          next_reward_on = P_.reward_times[V_.__t_reward_idx];
        }

        // stop either at next reward onset or t_curspike_, whichever is sooner
        double stopping_tp = std::min(t_curspike_, next_reward_on);

        // from previous t_ref_off, sample at regular intervals
        while (tp < stopping_tp) {
          int n_next_interval = (int)(floor((tp - t_ref_off) / P_.sampling_interval) + 1);
          double next_sampling_tp = t_ref_off + P_.sampling_interval * n_next_interval;

          t1 = std::min(next_sampling_tp, stopping_tp) - std::max(tp, t_ref_off);

          msg << "========---- >>> \tSampling " << t1 << " steps between [" << std::max(tp, t_ref_off)
              << " - " << std::min(next_sampling_tp, stopping_tp) << "]"<< std::endl;

          double t = 0.0;
          while ( t < t1 )
          {
            const int status = gsl_odeiv_evolve_apply(B_.__e, B_.__c, B_.__s, &B_.__sys, &t, t1,
                                                      &B_.__integration_step, S_.y_);
            if (status != GSL_SUCCESS) {
              throw nest::GSLSolverFailure("ShouvalConnection2", status);
            }
          }
          print_state(msg);
          tp += t1;
          store_interval_sampling_state(tp, tp);
        }
      }
    }
    LOG(M_DEBUG, "ShouvalConnection2::evolve_dynamics()", msg.str());
  }


  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  void
  send(Event &e, const thread tid, const ShouvalConnection2CommonSynapseProperties &cp) {
    const double t_spike = e.get_stamp().get_ms();
    Node *__target = get_target(tid);
    const double dendritic_delay = get_delay();

    std::ostringstream msg;
    msg << "\n=====================================\nProcessing spike @t: " << t_spike
        << "; synapse address @: " << this << "\n";

    if (t_lastspike_ < 0.)
    {
      t_lastspike_ = 0.;  // this is the first preynaptic spike to be processed
    }

    // ///////////////////////////////////////////////////////////////////////
    // get spike history in relevant range (t1, t2] from post-synaptic neuron
    std::deque<histentry>::iterator start;
    std::deque<histentry>::iterator finish;

    __target->get_history(t_lastspike_ - dendritic_delay, t_spike - dendritic_delay, &start, &finish);

    msg << "######### post-synaptic processing ##########\n";

    /////////////////////////////////////////////////////////////////////////
    // facilitation due to post-synaptic spikes since last pre-synaptic spike
    /////////////////////////////////////////////////////////////////////////
    while (start != finish) {
      msg << "--------------------------------------------------\n"
          << "start (" << start->t_ << ") != finish (" << finish->t_ << ")\n";
      /**
       * update synapse internal state from `t_lastspike_` to `start->t_`
      **/
      const double old___h = V_.__h;
      const double t_curspike_ = start->t_;

      V_.__h = (start->t_ + dendritic_delay) - t_lastspike_;
      // TODO is this necessary?
      // if first post-synaptic spike, we need to correct 1 step
//                if (t_lastspike_ == 0.)
      {
        V_.__h -= 1.;
      }
      init_internals_block_symbols();

      double rate_pre__tmp = V_.__P__rate_pre__rate_pre * S_.y_[State2_::rate_pre];
      double rate_post__tmp = V_.__P__rate_post__rate_post * S_.y_[State2_::rate_post];

      LOG(M_DEBUG, "ShouvalConnection2::send()", msg.str());
      msg.str("");
      // evolve system between t_last_spike_ and t_curspike_
      evolve_dynamics(t_curspike_);

      /* replace analytically solvable variables with precisely integrated values  */
      S_.y_[State2_::rate_pre] = rate_pre__tmp;
      S_.y_[State2_::rate_post] = rate_post__tmp;

      V_.__h = old___h;
      init_internals_block_symbols();  // XXX: can be skipped?

      /**
       *  NESTML generated postReceive code block begins here!
      **/
      S_.y_[State2_::rate_post] += 1.0;
      /**
       * internal state has now been fully updated to `start->t_ + dendritic_delay`
      **/
//                t_lastspike_ = start->t_ + dendritic_delay;
      t_lastspike_ = start->t_;
      msg << "internal state been fully updated to `start->t_ + dendritic_delay`"
          << "\n\t t_last_spike_: " << t_lastspike_
          << "\n";
      ++start;
    }
    msg << "################ [END] #################\n";
    msg << "----------------------------------------\n";
    msg << "######### pre-synaptic processing after all post-syn have been processed ##########\n";

    // ///////////////////////////////////////////////////////////////////////
    /**
     * update synapse internal state from `t_lastspike_` to `t_spike`
    **/
    const double old___h = V_.__h;
    msg << "[foo] V_.__h: " << V_.__h << " with t_lastspike__: " << t_lastspike_ << "\n";

    V_.__h = t_spike - t_lastspike_;
    msg << "[bar] V_.__h (pre) (t_spike - t_lastspike__): " << V_.__h << "\n";

    if (V_.__h > 1E-9) {
      msg << "EXTRA !! V_.__h > 1E-9, means we have to evolve " << V_.__h
          << " ms/steps till current tp.\n";

      init_internals_block_symbols();
      double rate_pre__tmp = V_.__P__rate_pre__rate_pre * S_.y_[State2_::rate_pre];
      double rate_post__tmp = V_.__P__rate_post__rate_post * S_.y_[State2_::rate_post];

      LOG(M_DEBUG, "ShouvalConnection2::send()", msg.str());
      msg.str("");

      evolve_dynamics(t_spike);

      /* replace analytically solvable variables with precisely integrated values  */
      S_.y_[State2_::rate_pre] = rate_pre__tmp;
      S_.y_[State2_::rate_post] = rate_post__tmp;
    }

    V_.__h = old___h;
//            init_internals_block_symbols();  // XXX: can be skipped?

    /**
     *  NESTML generated preReceive code block begins here!
    **/
    S_.y_[State2_::rate_pre] += 1.0;
    set_delay(P_.the_delay);
    const long __delay_steps = nest::Time::delay_ms_to_steps(get_delay());
    set_delay_steps(__delay_steps);
    e.set_receiver(*__target);

    e.set_weight(S_.y_[State2_::w]);
    // use accessor functions (inherited from Connection< >) to obtain delay in steps and rport
    e.set_delay_steps( get_delay_steps() );
    e.set_rport( get_rport() );
    e();;

    /**
     *  synapse internal state has now been fully updated to `t_spike`
    **/
    msg << "Synapse internal state has now been fully updated to `t_spike` " << t_spike << "ms with"
        << "\n\tS_.rate_pre (inc. +1): " << S_.y_[State2_::rate_pre]
        << "\n\tS_.rate_post: " << S_.y_[State2_::rate_post]
        << "\n";

    t_lastspike_ = t_spike;
    LOG(M_DEBUG, "ShouvalConnection2::send()", msg.str());
  }


private:

  double weight_;
  double t_lastspike_;




  struct ODEStruct_ {
    ODEStruct_();
    ODEStruct_(const ODEStruct_ &);

    /** GSL ODE stuff */
    gsl_odeiv_step* __s;    //!< stepping function
    gsl_odeiv_control* __c; //!< adaptive stepsize control function
    gsl_odeiv_evolve* __e;  //!< evolution function
    gsl_odeiv_system __sys; //!< struct describing system

    // IntergrationStep_ should be reset with the neuron on ResetNetwork,
    // but remain unchanged during calibration. Since it is initialized with
    // step_, and the resolution cannot change after nodes have been created,
    // it is safe to place both here.
    double __step;             //!< step size in ms
    double __integration_step; //!< current integration time step, updated by GSL
  };

  /* getters/setters for initial values block (excluding functions) */
  inline double get_w() const {
    return S_.y_[State2_::w];
  }

  inline void set_w(const double __v) {
    S_.y_[State2_::w] = __v;
  }

  inline double get_trace_ltp() const {
    return S_.y_[State2_::trace_ltp];
  }

  inline void set_trace_ltp(const double __v) {
    S_.y_[State2_::trace_ltp] = __v;
  }

  inline double get_trace_ltd() const {
    return S_.y_[State2_::trace_ltd];
  }

  inline void set_trace_ltd(const double __v) {
    S_.y_[State2_::trace_ltd] = __v;
  }

  inline double get_rate_pre() const {
    return S_.y_[State2_::rate_pre];
  }

  inline void set_rate_pre(const double __v) {
    S_.y_[State2_::rate_pre] = __v;
  }

  inline double get_rate_post() const {
    return S_.y_[State2_::rate_post];
  }

  inline void set_rate_post(const double __v) {
    S_.y_[State2_::rate_post] = __v;
  }

  /* getters/setters for parameters */
  inline double get_tau_w() const {
    return P_.tau_w;
  }

  inline void set_tau_w(const double __v) {
    P_.tau_w = __v;
  }

  inline double get_tau_ltp() const {
    return P_.tau_ltp;
  }

  inline void set_tau_ltp(const double __v) {
    P_.tau_ltp = __v;
  }

  inline double get_tau_ltd() const {
    return P_.tau_ltd;
  }

  inline void set_tau_ltd(const double __v) {
    P_.tau_ltd = __v;
  }

  inline double get_Tp_max() const {
    return P_.Tp_max;
  }

  inline void set_Tp_max(const double __v) {
    P_.Tp_max = __v;
  }

  inline double get_Td_max() const {
    return P_.Td_max;
  }

  inline void set_Td_max(const double __v) {
    P_.Td_max = __v;
  }

  inline double get_eta_ltp() const {
    return P_.eta_ltp;
  }

  inline void set_eta_ltp(const double __v) {
    P_.eta_ltp = __v;
  }

  inline double get_eta_ltd() const {
    return P_.eta_ltd;
  }

  inline void set_eta_ltd(const double __v) {
    P_.eta_ltd = __v;
  }

  inline double get_T_tr() const {
    return P_.T_tr;
  }

  inline void set_T_tr(const double __v) {
    P_.T_tr = __v;
  }

  inline double get_T_reward() const {
    return P_.T_reward;
  }

  inline void set_T_reward(const double __v) {
    P_.T_reward = __v;
  }

  inline double get_the_delay() const {
    return P_.the_delay;
  }

  inline void set_the_delay(const double __v) {
    P_.the_delay = __v;
  }

  inline double get_learn_rate() const {
    return P_.learn_rate;
  }

  inline void set_learn_rate(const double __v) {
    P_.learn_rate = __v;
  }

  inline std::vector< double > get_reward_times() const {
    return P_.reward_times;
  }

  inline void set_reward_times(const std::vector< double > __v) {
    P_.reward_times = __v;
  }

  //////
  inline double get_sampling_interval() const {
    return P_.sampling_interval;
  }

  inline void set_sampling_interval(const double __v) {
    P_.sampling_interval = __v;
  }

  //////
  inline std::vector< double > get_sampled_times() const {
    return V_.sampled_times;
  }

  inline void set_sampled_times(const std::vector< double > __v) {
    V_.sampled_times = __v;
  }

  //////
  inline std::vector< double > get_sampled_ltp() const {
    return V_.sampled_ltp;
  }

  inline void set_sampled_ltp(const std::vector< double > __v) {
    V_.sampled_ltp = __v;
  }

  //////
  inline std::vector< double > get_sampled_ltd() const {
    return V_.sampled_ltd;
  }

  inline void set_sampled_ltd(const std::vector< double > __v) {
    V_.sampled_ltd = __v;
  }

  //////
  inline std::vector< double > get_sampled_weights() const {
    return V_.sampled_weights;
  }

  inline void set_sampled_weights(const std::vector< double > __v) {
    V_.sampled_weights = __v;
  }

  //////
  inline std::vector< double > get_sampled_hebbian() const {
    return V_.sampled_hebbian;
  }

  inline void set_sampled_hebbian(const std::vector< double > __v) {
    V_.sampled_hebbian = __v;
  }

  struct Parameters_ {

    //!  filtering time constant for firing rate estimation
    double tau_w;

    double tau_ltp;

    double tau_ltd;

    double Tp_max;

    double Td_max;

    //!  Activation rate LTP trace
    double eta_ltp;

    //!  Activation rate LTD trace
    double eta_ltd;

    //!  Duration of refractory period for traces following neuromodulator presentation
    double T_tr;

    //!  duration of reward window
    double T_reward;

    //!  !! this is not mentioned in the paper!
    double the_delay;

    double learn_rate;

    double __gsl_error_tol;

    std::vector< double > reward_times;

//            double log_interval_sampling;  // log synapse state at regular intervals

    double sampling_interval;  // interval at which to sample traces / weights to log file

    /** Initialize parameters to their default values. */
    Parameters_() {};
  };

  struct Variables_ {
    double __h;

    unsigned __t_reward_idx;

    double __P__rate_pre__rate_pre;

    double __P__rate_post__rate_post;

    std::vector< double > sampled_times;
    std::vector< double > sampled_ltp;
    std::vector< double > sampled_ltd;
    std::vector< double > sampled_weights;
    std::vector< double > sampled_hebbian;
  };

  /**
* Internal variables of the synapse.
*
*
*
* These variables must be initialized by @c calibrate, which is called before
* the first call to @c update() upon each call to @c Simulate.
* @node Variables_ needs neither constructor, copy constructor or assignment operator,
*       since it is initialized by @c calibrate(). If Variables_ has members that
*       cannot destroy themselves, Variables_ will need a destructor.
*/

  Parameters_ P_;  //!< Free parameters.
  State2_ S_;  //!< Dynamic state.
  Variables_ V_;  //!< Internal Variables
  ODEStruct_ B_;  //!< Buffers / ODE integration variable
  SolverParams2_ SP_;


};

/**
* constructor
**/
template < typename targetidentifierT >
ShouvalConnection2< targetidentifierT >::ShouvalConnection2()
  :ConnectionBase()
{
//        P_.log_interval_sampling = 0.;
  P_.tau_w = 40.; // as ms
  P_.tau_ltp = 2000; // as ms
  P_.tau_ltd = 1000; // as ms
  P_.Tp_max = 0.95; // as real
  P_.Td_max = 1.0; // as real
  P_.eta_ltp = 1.;
  P_.eta_ltd = 0.55;
  P_.T_tr = 25; // as ms
  P_.T_reward = 25; // as ms
  P_.the_delay = 1; // as ms
  P_.learn_rate = 0.0045;
  P_.__gsl_error_tol = 1e-3;
  P_.sampling_interval = 0.;

  V_.__h = nest::Time::get_resolution().get_ms();
  V_.__t_reward_idx = 0;

  init_internals_block_symbols();
  init_buffers_();

  SP_.params[SolverParams2_::tau_w] = P_.tau_w;
  SP_.params[SolverParams2_::Tp_max_] = P_.Tp_max;
  SP_.params[SolverParams2_::Td_max_] = P_.Td_max;
  SP_.params[SolverParams2_::tau_ltp_] = P_.tau_ltp;
  SP_.params[SolverParams2_::tau_ltd_] = P_.tau_ltd;
  SP_.params[SolverParams2_::eta_ltp_] = P_.eta_ltp;
  SP_.params[SolverParams2_::eta_ltd_] = P_.eta_ltd;
  SP_.params[SolverParams2_::reward_on] = 0;
  SP_.params[SolverParams2_::refractory_on] = 0;
  SP_.params[SolverParams2_::learn_rate] = P_.learn_rate;

  S_.y_[State2_::rate_pre] = 0.0; // as real
  S_.y_[State2_::rate_post] = 0.0; // as real
  S_.y_[State2_::trace_ltd] = 0.0; // as real
  S_.y_[State2_::trace_ltp] = 0.0; // as real
  S_.y_[State2_::w] = 0.0; // as real

  t_lastspike_ = 0.;
}

template < typename targetidentifierT >
ShouvalConnection2< targetidentifierT >::ShouvalConnection2( const ShouvalConnection2< targetidentifierT >& rhs ):
  ConnectionBase(rhs), SP_(rhs.SP_), B_(rhs.B_)
{
  P_.tau_w = rhs.P_.tau_w;
  P_.tau_ltp = rhs.P_.tau_ltp;
  P_.tau_ltd = rhs.P_.tau_ltd;
  P_.Tp_max = rhs.P_.Tp_max;
  P_.Td_max = rhs.P_.Td_max;
  P_.eta_ltp = rhs.P_.eta_ltp;
  P_.eta_ltd = rhs.P_.eta_ltd;
  P_.T_tr = rhs.P_.T_tr;
  P_.T_reward = rhs.P_.T_reward;
  P_.the_delay = rhs.P_.the_delay;
  P_.learn_rate = rhs.P_.learn_rate;

  P_.reward_times = rhs.P_.reward_times;
  P_.sampling_interval = rhs.P_.sampling_interval;

  V_.__t_reward_idx = rhs.V_.__t_reward_idx;
  V_.sampled_times = rhs.V_.sampled_times;
  V_.sampled_ltp = rhs.V_.sampled_ltp;
  V_.sampled_ltd = rhs.V_.sampled_ltd;
  V_.sampled_weights = rhs.V_.sampled_weights;
  V_.sampled_hebbian = rhs.V_.sampled_hebbian;

  // state variables in ODE or kernel
  S_.y_[State2_::w] = rhs.S_.y_[State2_::w]; // as real
  S_.y_[State2_::rate_pre] = rhs.S_.y_[State2_::rate_pre]; // as real
  S_.y_[State2_::rate_post] = rhs.S_.y_[State2_::rate_post]; // as real
  S_.y_[State2_::trace_ltp] = rhs.S_.y_[State2_::trace_ltp]; // as real
  S_.y_[State2_::trace_ltd] = rhs.S_.y_[State2_::trace_ltd]; // as real

  t_lastspike_  = rhs.t_lastspike_;
}


template<typename targetidentifierT>
void
ShouvalConnection2<targetidentifierT>::get_status(DictionaryDatum &__d) const {
  ConnectionBase::get_status(__d);
  def< double >( __d, names::weight, weight_ );
  def<long>(__d, names::size_of, sizeof(*this));

  // parameters
  def<double>(__d, "tau_w", get_tau_w());
  def<double>(__d, "tau_ltp_", get_tau_ltp());
  def<double>(__d, "tau_ltd_", get_tau_ltd());
  def<double>(__d, "Tp_max_", get_Tp_max());
  def<double>(__d, "Td_max_", get_Td_max());
  def<double>(__d, "eta_ltp_", get_eta_ltp());
  def<double>(__d, "eta_ltd_", get_eta_ltd());
  def<double>(__d, "T_tr_", get_T_tr());
  def<double>(__d, "T_reward_", get_T_reward());
  def<double>(__d, names::delay, P_.the_delay);
  def<double>(__d, "learn_rate", get_learn_rate());
  def<std::vector<double>>(__d, "reward_times", get_reward_times());
  def<std::vector<double>>(__d, "sampled_times", get_sampled_times());
  def<std::vector<double>>(__d, "sampled_ltp", get_sampled_ltp());
  def<std::vector<double>>(__d, "sampled_ltd", get_sampled_ltd());
  def<std::vector<double>>(__d, "sampled_weights", get_sampled_weights());
  def<std::vector<double>>(__d, "sampled_hebbian", get_sampled_hebbian());
  def<double>(__d, "sampling_interval", get_sampling_interval());
  // TODO

  // initial values for state variables not in ODE or kernel

  // initial values for state variables in ODE or kernel
  def<double>(__d, "w", get_w());
  def<double>(__d, "trace_ltp", get_trace_ltp());
  def<double>(__d, "trace_ltd", get_trace_ltd());
  def<double>(__d, "rate_pre", get_rate_pre());
  def<double>(__d, "rate_post", get_rate_post());
}

template<typename targetidentifierT>
void
ShouvalConnection2<targetidentifierT>::set_status(const DictionaryDatum &__d,
                                                  ConnectorModel &cm) {
  // parameters
  double tmp_tau_w = get_tau_w();
  updateValue<double>(__d, "tau_w", tmp_tau_w);

  double tmp_tau_ltp = get_tau_ltp();
  updateValue<double>(__d, "tau_ltp_", tmp_tau_ltp);

  double tmp_tau_ltd = get_tau_ltd();
  updateValue<double>(__d, "tau_ltd_", tmp_tau_ltd);

  double tmp_Tp_max = get_Tp_max();
  updateValue<double>(__d, "Tp_max_", tmp_Tp_max);

  double tmp_Td_max = get_Td_max();
  updateValue<double>(__d, "Td_max_", tmp_Td_max);

  double tmp_eta_ltp = get_eta_ltp();
  updateValue<double>(__d, "eta_ltp_", tmp_eta_ltp);

  double tmp_eta_ltd = get_eta_ltd();
  updateValue<double>(__d, "eta_ltd_", tmp_eta_ltd);

  double tmp_T_tr = get_T_tr();
  updateValue<double>(__d, "T_tr_", tmp_T_tr);

  double tmp_T_reward = get_T_reward();
  updateValue<double>(__d, "T_reward_", tmp_T_reward);

  double tmp_the_delay = get_the_delay();
  updateValue<double>(__d, "the_delay", tmp_the_delay);

  double tmp_learn_rate = get_learn_rate();
  updateValue<double>(__d, "learn_rate", tmp_learn_rate);

  std::vector< double > tmp_reward_times = get_reward_times();
  updateValue< std::vector< double > >(__d, "reward_times", tmp_reward_times);

  std::vector< double > tmp_sampled_times = get_sampled_times();
  updateValue< std::vector< double > >(__d, "sampled_times", tmp_sampled_times);
  std::vector< double > tmp_sampled_ltp = get_sampled_ltp();
  updateValue< std::vector< double > >(__d, "sampled_ltp", tmp_sampled_ltp);
  std::vector< double > tmp_sampled_ltd = get_sampled_ltd();
  updateValue< std::vector< double > >(__d, "sampled_ltd", tmp_sampled_ltd);
  std::vector< double > tmp_sampled_weights = get_sampled_weights();
  updateValue< std::vector< double > >(__d, "sampled_weights", tmp_sampled_weights);
  std::vector< double > tmp_sampled_hebbian = get_sampled_hebbian();
  updateValue< std::vector< double > >(__d, "sampled_hebbian", tmp_sampled_hebbian);

  double tmp_w = get_w();
  updateValue<double>(__d, "w", tmp_w);

  double tmp_trace_ltp = get_trace_ltp();
  updateValue<double>(__d, "trace_ltp", tmp_trace_ltp);

  double tmp_trace_ltd = get_trace_ltd();
  updateValue<double>(__d, "trace_ltd", tmp_trace_ltd);

  double tmp_rate_pre = get_rate_pre();
  updateValue<double>(__d, "rate_pre", tmp_rate_pre);

  double tmp_rate_post = get_rate_post();
  updateValue<double>(__d, "rate_post", tmp_rate_post);

//        double tmp_log_interval_sampling = get_log_interval_sampling();
//        updateValue<double>(__d, "log_interval_sampling", tmp_log_interval_sampling);

  double tmp_sampling_interval = get_sampling_interval();
  updateValue<double>(__d, "sampling_interval", tmp_sampling_interval);

  // We now know that (ptmp, stmp) are consistent. We do not
  // write them back to (P_, S_) before we are also sure that
  // the properties to be set in the parent class are internally
  // consistent.
  ConnectionBase::set_status(__d, cm);

  // if we get here, temporaries contain consistent set of properties
  set_tau_w(tmp_tau_w);
  set_tau_ltp(tmp_tau_ltp);
  set_tau_ltd(tmp_tau_ltd);
  set_Tp_max(tmp_Tp_max);
  set_Td_max(tmp_Td_max);
  set_eta_ltp(tmp_eta_ltp);
  set_eta_ltd(tmp_eta_ltd);
  set_T_tr(tmp_T_tr);
  set_T_reward(tmp_T_reward);
  set_the_delay(tmp_the_delay);
  set_learn_rate(tmp_learn_rate);
  set_reward_times(tmp_reward_times);
  set_w(tmp_w);
  set_trace_ltp(tmp_trace_ltp);
  set_trace_ltd(tmp_trace_ltd);
  set_rate_pre(tmp_rate_pre);
  set_rate_post(tmp_rate_post);

//        set_log_interval_sampling(tmp_log_interval_sampling);
  set_sampling_interval(tmp_sampling_interval);

  set_sampled_times(tmp_sampled_times);
  set_sampled_ltp(tmp_sampled_ltp);
  set_sampled_ltd(tmp_sampled_ltd);
  set_sampled_weights(tmp_sampled_weights);
  set_sampled_hebbian(tmp_sampled_hebbian);

  SP_.params[SolverParams2_::tau_w] = P_.tau_w;
  SP_.params[SolverParams2_::tau_ltp_] = P_.tau_ltp;
  SP_.params[SolverParams2_::tau_ltd_] = P_.tau_ltd;
  SP_.params[SolverParams2_::Tp_max_] = P_.Tp_max;
  SP_.params[SolverParams2_::Td_max_] = P_.Td_max;
  SP_.params[SolverParams2_::learn_rate] = P_.learn_rate;
}



template<typename targetidentifierT>
ShouvalConnection2<targetidentifierT>::ODEStruct_::ODEStruct_():
  __s( 0 ), __c( 0 ), __e( 0 )
{
}

template<typename targetidentifierT>
ShouvalConnection2<targetidentifierT>::ODEStruct_::ODEStruct_(const ODEStruct_ &ode)
{
  __s = ode.__s;
  __c = ode.__c;
  __e = ode.__e;
  __sys = ode.__sys;
  __step = ode.__step;
  __integration_step = ode.__integration_step;
}


template < typename targetidentifierT >
void ShouvalConnection2< targetidentifierT >::init_buffers_()
{
  if ( B_.__s == 0 )
  {
    B_.__s = gsl_odeiv_step_alloc( gsl_odeiv_step_rkf45, State2_::State2_VEC_SIZE );
  }
  else
  {
    gsl_odeiv_step_reset( B_.__s );
  }

  if ( B_.__c == 0 )
  {
    B_.__c = gsl_odeiv_control_y_new( P_.__gsl_error_tol, 0.0 );
  }
  else
  {
    gsl_odeiv_control_init( B_.__c, P_.__gsl_error_tol, 0.0, 1.0, 0.0 );
  }

  if ( B_.__e == 0 )
  {
    B_.__e = gsl_odeiv_evolve_alloc( State2_::State2_VEC_SIZE );
  }
  else
  {
    gsl_odeiv_evolve_reset( B_.__e );
  }

  assert(B_.__c);
  assert(B_.__e);
  assert(B_.__s);
  assert(&B_.__sys);

  B_.__sys.function = ShouvalConnection2Dynamics;
  B_.__sys.jacobian = NULL;
  B_.__sys.dimension = State2_::State2_VEC_SIZE;
//        B_.__sys.params = NULL; //reinterpret_cast< void* >( this );
  B_.__sys.params = reinterpret_cast< void* >( &SP_ );

  B_.__step = nest::Time::get_resolution().get_ms();
  B_.__integration_step = nest::Time::get_resolution().get_ms();
}


template < typename targetidentifierT >
void ShouvalConnection2< targetidentifierT >::init_internals_block_symbols()
{
  V_.__P__rate_pre__rate_pre = std::exp((-V_.__h) / P_.tau_w);
  V_.__P__rate_post__rate_post = std::exp((-V_.__h) / P_.tau_w);
}

} // namespace

#endif /* #ifndef TTL_SYNAPSE_H */